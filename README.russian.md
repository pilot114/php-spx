# SPX - Простой профилировщик для PHP

[![Build Status](https://travis-ci.org/NoiseByNorthwest/php-spx.svg?branch=master)](https://travis-ci.org/NoiseByNorthwest/php-spx) ![Supported PHP versions: 5.6 .. 7.x](https://img.shields.io/badge/php-5.6--7.4-blue.svg) ![Supported platforms: GNU/Linux 64-bit, macOS 64-bit](https://img.shields.io/badge/platform-GNU/Linux%20|%20macOS%20-yellow)

[Демо](https://noisebynorthwest.github.io/php-spx/demo/report.html?key=spx-full-20191229_175636-06d2fe5ee423-3795-233665123)

![Showcase](https://github.com/NoiseByNorthwest/NoiseByNorthwest.github.io/blob/d8a90827d6eb256f49d580de448b6b6fad4119ac/php-spx/doc/as.apng)

![Showcase](https://github.com/NoiseByNorthwest/NoiseByNorthwest.github.io/blob/43e3ffe185a1dcec70e7c8ced36acfdf316bae65/php-spx/doc/fp1.gif)

SPX, что означает _Simple Profiling eXtension_, является еще одним расширением для профилирования PHP.
SPX отличается от других профилировщиков следующим:
* полностью свободен и автономен (нет утечки данных в SaaS).
* очень прост в использовании: установите переменную окружения (CLI) или переключите чекбокс (web страница) чтобы профилировать ваш скрипт. Таким образом вы можете:
  * вручную работать с кодом (долгоработающие CLI скрипты также поддерживаются).
  * использовать расширения для браузера и CLI лаунчеры.
* [поддержка множества метрик](#доступные-метрики): в данный момент их 21 (различные временные метрики, память, подключаемые файлы, используемые объекты, I/O...).
* возможность собирать данные без потери контекста. Например, Xhprof (и потенциально его форки) собирает данные по парам вызывающий-вызываемый, что ведет к потере полного стека вызовов и делает невозможным анализ на базе временной шкалы или Flamegraph-а.
* встроенный [web UI](#web-ui), который предоставляет:
  * включение / настройку профилирования для текущей браузерной сессии
  * список отчетов профилирования
  * выбор отчета для углубленного анализа с помощью интерактивных визуализаций:
    * таймлайн (маштабируется до миллионов вызовов функций)
    * плоский профиль
    * Flamegraph

## Требования

В настоящее время поддержка платформ довольно ограничена. Не стесняйтесь открывать issue, если ваша платформа не поддерживается.
Текущие требования такие:

* x86-64
* **GNU/Linux** или **macOS**
* zlib dev пакет (например, zlib1g-dev на Debian-based дистрибутивах)
* PHP 5.6 или 7+
* Не ZTS (многопоточная) сборка PHP (поддержка ZTS теоретическая)

## Установка

### Необходимые условия

* PHP девпакет (соответствующий установленной версии PHP).
* zlib девпакет:
  * Для Debian-based дистрибутивов (влючая Ubuntu, Kubuntu...), просто запустите: `sudo apt-get install zlib1g-dev`.

### Установка расширения

```shell
git clone https://github.com/NoiseByNorthwest/php-spx.git
cd php-spx
phpize
./configure
make
sudo make install
```

Затем добавьте `extension=spx.so` в ваш *php.ini*, или в отдельный *spx.ini* файл, созданный в include каталоге.
Вы также можете переопределить [конфигурацию SPX по умолчанию](#configuration), например, [для локальной разработки](#private-environment).

### Linux, PHP-FPM & I/O статистика

На GNU/Linux, SPX использует procfs (т.е. путем чтения файлов в `/proc`) чтобы получить I/O статистику текущего потока. Это то, что делается под капотом, когда вы выбираете одну из 3 метрик: `io`, `ior` или `iow`.

Но на большинстве PHP-FPM установок, выбудете иметь проблемы с правами, не позволяющими SPX открыть `/proc/self/task/<thread Id>/io`.
Это связанно с тем, что мастер процесс PHP-FPM запускается под рутом, в то время как дочерние процессы запускаются из под непривилегированного пользователя.

В этом случае необходимо добавить строку `process.dumpable = yes` в конфигурацию FPM, чтобы дочерние процессы могли читать `/proc/self/task/<thread Id>/io`.

## Статус разработки

Это ещё **экпериментальное** расширение. API может меняться, функции могут быть добавлены или удалены, или разработка может быть заморожена.

Вы можете безопасно использовать расширение в **не-продакшен** среде.

Вклад в разработку приветствуется, но имейте в виду экспериментальный статус проекта и **следуйте правилам**, описанным здесь: [CONTRIBUTING.md](CONTRIBUTING.md)

## Базовое использование

### Веб страница

Предполагая среду разработки [описанную здесь](#Защищенное-окружение) ваше приложение доступно по адресу `http://localhost`.

Просто откройте в своем браузере следующий URL: `http://localhost/?SPX_KEY=dev&SPX_UI_URI=/` чтобы получить доступ к web UI [панели управления](#панель-управления-и-список-отчетов).

_Прим.: Предполагается что `http://localhost/` обращается к PHP скрипту через стандартную функцию веб сервера, такую как индекс каталога или URL rewriting. Если это не так, вы можете явно указать существующий PHP скрипт, как в этом примере: `http://localhost/my_application.php?SPX_KEY=dev&SPX_UI_URI=/`. При этом скрипт не будет выполнен, SPX будет перехватывать и отключать его выполнение._

Затем вы увидите следующую форму:

![Showcase](https://github.com/NoiseByNorthwest/NoiseByNorthwest.github.io/blob/93baabbcba04223586d06756dbcecfbd6ec1293d/php-spx/doc/cp-form.png)

Далее нажмите "Enabled". Теперь профилирование включено для текущего домена и текущего сеанса браузера с помощью cookie.

При обновлении страницы, которую вы хотите профилировать, вы увидите сгенерированный отчет в списке под формой панели управления.

![Showcase](https://github.com/NoiseByNorthwest/NoiseByNorthwest.github.io/blob/d8a90827d6eb256f49d580de448b6b6fad4119ac/php-spx/doc/cp-list2.png)

Нажмите на отчет в списке и наслаждайтесь [экраном анализа](#экран-анализа).

### CLI

#### Мгновенное плоское профилирование

Добавьте в командной строке `SPX_ENABLED=1` чтобы запустить профилирование. Вы получите плоский отчет на STDERR в конце выполнения, даже в случае отмены на Ctrl-C, как в следующем примере:

```shell
$ SPX_ENABLED=1 composer update
Loading composer repositories with package information
Updating dependencies (including require-dev)
^C
*** SPX Report ***

Global stats:

  Called functions    :    27.5K
  Distinct functions  :      714

  Wall time           :    7.39s
  ZE memory           :   62.6MB

Flat profile:

 Wall time           | ZE memory           |
 Inc.     | *Exc.    | Inc.     | Exc.     | Called   | Function
----------+----------+----------+----------+----------+----------
  101.6ms |  101.6ms |   41.8MB |   41.8MB |       12 | Composer\Json\JsonFile::parseJson
   53.6ms |   53.6ms |     544B |     544B |        4 | Composer\Cache::sha256
    6.91s |   41.5ms |   41.5MB |   -7.5MB |        4 | Composer\Repository\ComposerRepository::fetchFile
    6.85s |   32.3ms |   47.5MB |    5.4MB |        5 | 1@Composer\Repository\ComposerRepository::loadProviderListings
    7.8ms |    7.8ms |       0B |       0B |        4 | Composer\Cache::write
    1.1ms |    1.1ms |     -72B |     -72B |        1 | Composer\Console\Application::Composer\Console\{closure}
  828.5us |  828.5us |     976B |     976B |       12 | Composer\Util\RemoteFilesystem::findHeaderValue
  497.6us |  491.0us |  710.2KB |  710.2KB |        1 | Composer\Cache::read
    2.4ms |  332.6us |   20.9KB | -378.8KB |       34 | 3@Symfony\Component\Finder\Iterator\FilterIterator::rewind
  298.9us |  298.9us |    2.2KB |    2.2KB |       47 | Symfony\Component\Finder\Iterator\FileTypeFilterIterator::accept
```

_Прим.: Добавьте `SPX_FP_LIVE=1` чтобы включить обновление плоского отчета в реальном времени._

#### Создать отчет профилирования для веб-интерфейса

Можно указать `SPX_REPORT=full` чтобы сгенерировать отчет для web UI:

```shell
SPX_ENABLED=1 SPX_REPORT=full ./bin/console cache:clear
```


#### Профилирование долгоживущих процессов / демонов

Если CLI скрипт выполняется долго или запущен как демон (например, через supervisord), его полное профилирование будет бессмысленным. Это особенно верно в случае службы, ожидающей обработки задач.  
Чтобы справиться с этим, SPX предоставляет 2 пользовательские функции позволяющие включать и выключать профилирование, `spx_profiler_start(): void` & `spx_profiler_stop(): void`, чтобы соответственно контролировать начало и конец участка профилирования.  

Вот так вы можете использовать свой скрипт:

```php
<?php

while ($task = get_next_ready_task()) {
  spx_profiler_start();
  try {
    $task->process();
  } finally {
    spx_profiler_stop();
  }
}

```

И конечно, скрипт должен быть запущен с включенным профилированием и выключенным автоматическим стартом, что можно сделать следующей командой:

```shell
SPX_ENABLED=1 SPX_REPORT=full SPX_AUTO_START=0 my_script.php
```

Примечания:
- `spx_profiler_start()` и `spx_profiler_stop()` могут быть безопасно вложены.
- если автоматический запуск отключен, SPX не регистрирует обработчики сигналов (такие как SIGINT/SIGTERM).
- автоматический запуск может быть отключен только для CLI SAPI.


## Расширенное использование

### Конфигурация

| Название              | По умолчанию  | Режим  | Описание  |
| --------------------- | -------- | ----------- | ------------ |
| spx.data_dir     | `/tmp/spx` | PHP_INI_SYSTEM | Каталог, где будут храниться отчеты профилирования. Можно указать общую файловую системы в случае многосервисной архитектуры  |
| spx.http_enabled      | `0`  | PHP_INI_SYSTEM | Включить ли web UI и профилирование HTTP запросов. |
| spx.http_key          |  | PHP_INI_SYSTEM | Секретный ключ, используемыйй для аутентификации (см. [безопасность](#security-concern) для подробностей). Вы можете использовать следующую команду для генерации 16-байтового случайного ключа в виде hex строки: `openssl rand -hex 16`. |
| spx.http_ip_var       | `REMOTE_ADDR` | PHP_INI_SYSTEM | `$_SERVER` с IP адресом клиента используется для аутентификации (см. [безопасность](#security-concern) для подробностей). Перезапись дефолтного значения требуется, когда ваше приложение находится за обратным прокси-сервером. |
| spx.http_trusted_proxies       | `127.0.0.1` | PHP_INI_SYSTEM | Список доверенных прокси в виде списка IP-адресов, разделенных запятыми. Этот параметр игнорируется, если значением `spx.http_ip_var` является `REMOTE_ADDR`. |
| spx.http_ip_whitelist |  | PHP_INI_SYSTEM | Белый список IP адресов, используемый для аутентфикации в виде спсика IP-адресов, разделенных запятыми, используйте `*` чтобы разрешить все IP-адреса. |
| spx.http_ui_assets_dir | `/usr/local/share/misc/php-spx/assets/web-ui` | PHP_INI_SYSTEM | Директория, куда [web UI](#web-ui) файлы будут установлены. В большинстве случаев вам не нужно менять это. |


#### Защищенное окружение

Для локального и защищенного рабочего окружения, поскольку нет необходимости в аутентификации, вы можете использовать следующую конфигурацию:

```
spx.http_enabled=1
spx.http_key="dev"
spx.http_ip_whitelist="127.0.0.1"
```

И затем иметь доступ к web UI по `http(s)://<your application host>/?SPX_KEY=dev&SPX_UI_URI=/`.

### Доступные метрики

Список доступных для сбора метрик. По умолчанию собирается только _Wall time_ и _Zend Engine memory usage_.

| Ключ (командная строка) | Название | Описание |
| ---- | ---------------- | ------ |
| _wt_ | Wall time | Абсолютное истекшее время. |
| _ct_ | CPU time | Время работы процессора. |
| _it_ | Idle time | Время вне работы процессора. |
| _zm_ | Zend Engine memory usage | Эквивалент `memory_get_usage(false)`. |
| _zmac_ | Zend Engine allocation count | Количество выполненных выделений памяти (то есть выделенных блоков). |
| _zmab_ | Zend Engine allocated bytes<b>*</b> | Количество выделенных байтов. |
| _zmfc_ | Zend Engine free count | Количество выполненных освобождений памяти (то есть освобожденных блоков). |
| _zmfb_ | Zend Engine freed bytes<b>*</b> | Количество освобожденных байтов. |
| _zgr_ | Zend Engine GC run count | Количество срабатываний GC (вручную или автоматически). |
| _zgb_ | Zend Engine GC root buffer length | Длина корневого буфера, [подробнее](http://php.net/manual/en/features.gc.collecting-cycles.php). Может быть полезно чтобы отследить нагрузку на сборщик мусора. |
| _zgc_ | Zend Engine GC collected cycle count | Общее количество собранных циклов за все прогоны GC. |
| _zif_ | Zend Engine included file count | Количество включаемых файлов. |
| _zil_ | Zend Engine included line count | Количество включаемых строк. |
| _zuc_ | Zend Engine user class count | Количество пользовательских классов. |
| _zuf_ | Zend Engine user function count | Количество функций пользовательского пространства (включая методы). |
| _zuo_ | Zend Engine user opcode count | Количество опкодов пользовательского пространства (сумма всех кодов операций). |
| _zo_ | Zend Engine object count | Количество объектов, хранящихся в данный момент по коду пользователя. |
| _ze_ | Zend Engine error count | Количество поднятых ошибок PHP. |
| _io_ | I/O (reads + writes)**\*\*** | Чтение или запись байтов при выполнении ввода / вывода. |
| _ior_ | I/O (reads)**\*\*** | Чтение байтов при выполнении ввода / вывода. |
| _iow_ | I/O (writes)**\*\*** | Запись байтов при выполнении ввода / вывода. |

_\*: Количество выделенных и освобожденных байтов не будет собираться, если вы используете собственный аллокатор или если вы установите переменную окружения `USE_ZEND_ALLOC` в `0`._

_\*\*: I/O метрики не поддерживаются на macOS. В GNU/Linux вы должны [прочитать это, если используете PHP-FPM](#linux-php-fpm--io-stats)._

### CLI

#### Доступные типы отчетов

В отличие от профилирования веб-страниц, которые поддерживают только _full_ тип отчета (единственный используемый в web UI), профилирование сценариев командной строки поддерживает несколько типов отчетов.
Вот список:

| Ключ  | Имя  | Описание  |
| ---- | ----- | ------------ |
| _fp_ | Flat profile | Плоский отчет SPX. Это **тип отчета по умолчанию** и он выводится напрямую в STDERR. |
| _full_ | Full report | Тип отчета для web UI. Отчеты хранятся в каталоге данных SPX и, таким образом, доступны для анализа на стороне веб-интерфейса. |
| _trace_ | Trace file | Файл трассировки пользовательского формата (читаемый человеком текст). |

#### Доступные параметры

| Имя  | Значение по умолчанию  | Описание  |
| ----- | -------- | ------------ |
| _SPX_ENABLED_ | `0` | Нужно ли включать профилировщик SPX (то есть запуск профилирования). При отключении не влияет на производительность вашего приложения. |
| _SPX_AUTO_START_ | `1` | Включать ли автоматический запуск SPX-профилировщика. Когда автоматический запуск отключен, вы должны запускать и останавливать профилирование самостоятельно во время выполнения через `spx_profiler_start()` и `spx_profiler_stop()` функции. [Смотри здесь](#handle-long-living--daemon-processes) для подробностей. |
| _SPX_BUILTINS_ | `0` | Нужно ли профилировать внутренние функции, компиляцию сценариев, запускать GC и запрашивать завершение работы. |
| _SPX_DEPTH_ | `0` | Глубина стека, на которой должно быть остановлено профилирование. 0 (значение по умолчанию) означает что глубина неограниченна. |
| _SPX_SAMPLING_PERIOD_ | `0` | Собирать ли данные для текущего стека вызовов через регулярные интервалы в соответствии с заданным периодом выборки (`0` означает отсутствие выборки). Результат обычно будет менее точным, но в некоторых случаях он может быть гораздо более точным, если не переоценивать маленькие функции, вызываемые много раз. Рекомендуется попробовать выборку (с разными периодами), если вы хотите точно найти узкое место по времени. При профилировании долго выполняющегося и интенсивно загружающего ЦП сценария этот параметр позволит вам уменьшить размер отчета чтобы его можно было использовать а [web UI](#web-ui). Смотри [здесь](#performance-report-size--sampling) для подробностей. |
| _SPX_METRICS_ | `wt,zm` | Разделенный запятыми список [доступных метрик](#available-metrics) для сбора. Все типы отчетов используют мультиметрическое профилирование. |
| _SPX_REPORT_ | `fp` | Выбраный [тип отчета](#available-report-types). |
| _SPX_FP_FOCUS_ | `wt` | [Метрика](#available-metrics) для сортировки плоского отчета. |
| _SPX_FP_INC_ | `0` | Сортировать ли функции по инклюзивному значению вместо монопольного значения в плоском профиле. |
| _SPX_FP_REL_ | `0` | Отображать ли значения метрик как относительные (т.е. в процентах) в плоском профиле. |
| _SPX_FP_LIMIT_ | `10` | Размер плоского профиля (т.е. первые N показанных функций). |
| _SPX_FP_LIVE_ | `0` | Нужно ли включать real-time обновление плоского профиля. Так как для работы с курсором используются ANSI последовательности, STDOUT и STDERR вывод скрипта заменяется на STDOUT. |
| _SPX_FP_COLOR_ | `1` | Нужно ли включать цветной режим плоского профиля. |
| _SPX_TRACE_SAFE_ | `0` | Файл трассировки по умолчанию написан таким образом, чтобы обеспечить точность, но в случае сбоя процесса (например, segfault) некоторые журналы могут быть потеряны. Если вы хотите обеспечить надежность (например, чтобы найти последнее событие перед сбоем), вам просто нужно установить для этого параметра значение 1. |
| _SPX_TRACE_FILE_ |  | Имя файла трассировки. Если он не указан, он будет сгенерирован в /tmp и отображен в STDERR в конце скрипта. |

#### Настройка параметров

Как вы уже могли заметить в соответствующем [базовом примере использования](#command-line-script), установка параметра SPX для сценария командной строки просто означает установку переменной среды с тем же именем.

### Web UI

#### Поддерживаемые браузеры

Поскольку веб-интерфейс использует расширенные функции JavaScript, известно, что поддерживаются только следующие браузеры:
- последняя версия любого браузера на основе Chromium.
- последняя версия Firefox с настройкой `dom.moduleScripts.enabled` установленной в `true`.

#### Панель управления и список отчетов

Главная страница веб-интерфейса, разделена на 2 части:
- панель управления для настройки параметров профилирования для текущего сеанса браузера.
- список отчетов профиля в виде сортируемой таблицы. Щелчок по строке позволяет перейти к [экрану анализа](#analysis-screen) соответствующего отчета.

#### Экран анализа

[Нажми здесь чтобы увидеть демо экрана анализа](https://noisebynorthwest.github.io/php-spx/demo/report.html?key=spx-full-20180603_211110-dev-3540-294703905)

![Showcase](https://github.com/NoiseByNorthwest/NoiseByNorthwest.github.io/blob/d8a90827d6eb256f49d580de448b6b6fad4119ac/php-spx/doc/as.th.png)

##### Производительность, размер отчета и выборка

Экран анализа может обрабатывать отчеты профиля с несколькими (5+) миллионами записанных вызовов функций в Chromium на моём i5 @ 3.3GHz / 8GB ПК.
Если вы хотите профилировать длительный, интенсивно использующий процессор сценарий, который генерирует гигантские отчеты, вы можете включить режим выборки с подходящим периодом выборки.
См. [параметр](#available-parameters) _SPX_SAMPLING_PERIOD_ для сценария командной строки.

##### Выбор метрик

Это просто поле со списком для выбора текущей анализируемой метрики.

![Showcase](https://github.com/NoiseByNorthwest/NoiseByNorthwest.github.io/blob/d8a90827d6eb256f49d580de448b6b6fad4119ac/php-spx/doc/as-ms.png)

##### Выбор цветовой схемы

По умолчанию блоки, связанные с функциями в визуализациях, окрашены в соответствии с их стоимостью, а цветная шкала отображается в верхнем правом углу экрана.

Вы также можете определить собственную цветовую схему, нажав на режим выбора цветовой схемы, отображаемый в верхней части экрана сразу после выбора метрик.
Затем появится раскрывающееся окно, в котором можно переключаться между режимом `по умолчанию` и режимом `категории` и определять (добавлять / редактировать / удалять) свои категории (цвет, имя, список шаблонов) для режима `категории` (см. Скриншот ниже).

![Showcase](https://github.com/NoiseByNorthwest/NoiseByNorthwest.github.io/blob/d8a90827d6eb256f49d580de448b6b6fad4119ac/php-spx/doc/as-csm.png)

##### Обзор временной шкалы

Эта визуализация представляет собой обзор временной шкалы всех вызываемых функций. 
Вы можете изменить выбранный диапазон времени, представленный прозрачным зеленым прямоугольником, просто перетащив его по горизонтали.

За исключением wall time, текущая метрика также отображается на переднем плане.

Поддерживаемые элементы управления:
- горизонтальное перетаскивание левой кнопкой мыши: сдвиг выбранного временного диапазона
- для изменения размера выбранного временного диапазона: сдвиньте одну из границ выбранного временного диапазона

![Showcase](https://github.com/NoiseByNorthwest/NoiseByNorthwest.github.io/blob/d8a90827d6eb256f49d580de448b6b6fad4119ac/php-spx/doc/as-ov.png)

##### Фокус временной шкалы

Эта визуализация представляет собой интерактивную временную шкалу, которая может контролировать и сохранять фокус на выбранном временном диапазоне.

Поддерживаемые элементы управления:
- перетаскивание левой кнопкой мыши: сдвиг диапазона времени (по горизонтали) или сдвиг диапазона глубины (по вертикали)
- вертикальное перетаскивание средней кнопкой мыши: увеличение / уменьшение диапазона времени
- колесо мыши: увеличение / уменьшение диапазона времени
- наведение курсора на вызов функции, чтобы показать больше деталей
- двойной щелчок на вызове функции: установить текущий диапазон времени как выбранный вызов функции

За исключением wall time, текущая метрика также отображается на переднем плане.

![Showcase](https://github.com/NoiseByNorthwest/NoiseByNorthwest.github.io/blob/d8a90827d6eb256f49d580de448b6b6fad4119ac/php-spx/doc/as-tl.png)

##### Плоский отчет

Эта визуализация представляет собой плоский профиль для выбранного временного диапазона и выбранной метрики, отображаемый в виде сортируемой таблицы.

![Showcase](https://github.com/NoiseByNorthwest/NoiseByNorthwest.github.io/blob/d8a90827d6eb256f49d580de448b6b6fad4119ac/php-spx/doc/as-fp.png)

##### Flame Graph

Эта визуализация, разработанная [Brendan Gregg](http://www.brendangregg.com/flamegraphs.html), позволяет быстро найти "горячий код" для выбранного временного диапазона и выбранной метрики. 
Метрики, соответствующие высвобождаемым ресурсам (память, используемые объекты ...), не поддерживаются этой визуализацией.

![Showcase](https://github.com/NoiseByNorthwest/NoiseByNorthwest.github.io/blob/d8a90827d6eb256f49d580de448b6b6fad4119ac/php-spx/doc/as-fg.png)


##### Подсветка функций

Вы можете выделить функцию, щелкнув на один из ее диапазонов в виджете шкалы времени или Flamegraph или на её имя в виджете плоского профиля.

![Showcase](https://github.com/NoiseByNorthwest/NoiseByNorthwest.github.io/blob/47d8f8d93fad1e6659c46c47e5aa8f82822454a9/php-spx/doc/as-fh.png)


## Безопасность

_Отсутствие обзора / отзывов об этой проблеме является основной причиной того, что **SPX еще нельзя считать готовым к продакшену**._

SPX позволяет профилировать веб-страницу, а также сценарии командной строки, а также просматривать и анализировать профильные отчеты с помощью встроенного веб-интерфейса.
Вот почему существует огромный риск для безопасности, поскольку злоумышленник может:
 - получить доступ к веб-интерфейсу, что дает важную информацию о вашем приложении.
 - в меньшей степени, провести DoS-атаку на ваше приложение через дорогостоящее профилирование.

So, unless access to your application is already restricted at lower layer (i.e. before your application is hit, not by the application / PHP framework itself), a client triggering profiling or accessing to the web UI must be authenticated.

Таким образом, если доступ к вашему приложению не ограничен на нижнем уровне (т.е. до вызова приложения / PHP фреймворка), клиент, запускающий профилирование или имеющий доступ к веб-интерфейсу, должен пройти проверку подлинности.

SPX обеспечивает двухфакторную аутентификацию с 2 обязательными блокировками:
* Белый список IP-адресов (точное соответствие строкового представления).
* Фиксированный секретный случайный ключ (сгенерированный самостоятельно), предоставляемый через заголовок запроса, cookie или параметр строки запроса.

Таким образом, клиент может профилировать ваше приложение через веб-страницу только в том случае, если его **IP-адрес указан в белом списке, а предоставленный ключ действителен**.

## Примечания к точности

В режиме трассировки (по умолчанию) SPX подвержен проблемам с точностью для временных метрик, когда измеренное время выполнения функции составляет:
- величину, сравнимую с точностью таймера
- величину, сравнимую с собственным оверхедом SPX

Первая проблема устраняется с помощью таймера с самым высоким разрешением, предоставляемым платформой. На Linux и последней версии macOS разрешение таймера 1нс; на macOS до 10.12/Sierra, разрешение таймера 1мкс.

Вторая проблема устраняется путем учета накладных расходов времени (wall / cpu) SPX путем вычитания их из измеренного времени выполнения функции. Это делается путем оценки константы SPX для каждой функции перед началом профилирования скрипта.

Однако, независимо от платформы, если вы хотите максимизировать точность, чтобы найти узкое место во времени, вам также следует:
- избегать профилирования внутренних функций.
- избегать сбора лишних метрик.
- попробовать разные режим выборки с разными периодами выборки.
- попробовать поиграть с параметром максимальной глубины, чтобы остановить профилирование на заданной глубине.

## Благодарности

Я нашел много вдохновения и подсказок, читая:
 - [XHProf](https://github.com/phacility/xhprof)
 - [Xdebug](https://github.com/xdebug/xdebug)
 - [PHP](https://github.com/php/php-src)
